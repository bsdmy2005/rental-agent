# WhatsApp Status Management Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement robust WhatsApp server status monitoring with auto-reconnect, health check APIs, and front-end status indicators.

**Architecture:** Server-side auto-reconnect on startup loads primary sessions with auth state and connects them. Enhanced health endpoints (light + deep) enable front-end polling. React context provides status to components. Binary green/red indicators show in header and sidebar with click-for-details.

**Tech Stack:** TypeScript, Express (WhatsApp server), Next.js 15, React Context, Shadcn UI, Drizzle ORM, PostgreSQL

---

## Task 1: Add auto_connect Column to Database Schema

**Files:**
- Modify: `db/schema/whatsapp-sessions.ts`
- Create: `db/migrations/0039_whatsapp_auto_connect.sql` (generated by drizzle-kit)

**Step 1: Add auto_connect column to schema**

Edit `db/schema/whatsapp-sessions.ts`, add after `isActive` field (line 27):

```typescript
  // Auto-connect on server startup (only for primary sessions)
  autoConnect: boolean("auto_connect").notNull().default(true),
```

**Step 2: Generate migration**

Run: `npx drizzle-kit generate`
Expected: New migration file created in `db/migrations/`

**Step 3: Verify migration SQL**

Read the generated migration file and confirm it contains:
```sql
ALTER TABLE "whatsapp_sessions" ADD COLUMN "auto_connect" boolean DEFAULT true NOT NULL;
```

**Step 4: Commit**

```bash
git add db/schema/whatsapp-sessions.ts db/migrations/
git commit -m "feat(schema): add auto_connect column to whatsapp_sessions"
```

---

## Task 2: Create Health Routes for WhatsApp Server

**Files:**
- Create: `whatsapp-server/src/routes/health.ts`
- Modify: `whatsapp-server/src/routes/index.ts`
- Modify: `whatsapp-server/src/index.ts`

**Step 1: Create health routes file**

Create `whatsapp-server/src/routes/health.ts`:

```typescript
import { Router, Request, Response, NextFunction } from "express"
import { ConnectionManager } from "../baileys/connection-manager.js"
import { Pool } from "pg"
import { env } from "../config/env.js"
import { createLogger } from "../utils/logger.js"

const logger = createLogger("routes/health")
const router = Router()

// Track server start time for uptime calculation
const serverStartTime = Date.now()

/**
 * Lightweight health check - no auth required
 * Used for frequent polling (every 30s)
 */
router.get("/", async (_req: Request, res: Response) => {
  const manager = ConnectionManager.getInstance()
  const sessions = manager.getAllSessionsStatus()

  const connected = sessions.filter(s => s.connectionStatus === "connected").length
  const connecting = sessions.filter(s => s.connectionStatus === "connecting" || s.connectionStatus === "qr_pending").length
  const disconnected = sessions.filter(s => s.connectionStatus === "disconnected" || s.connectionStatus === "logged_out").length

  // Determine overall status
  let status: "ok" | "degraded" | "error" = "ok"
  if (disconnected > 0 && connected === 0) {
    status = "error"
  } else if (disconnected > 0 || connecting > 0) {
    status = "degraded"
  }

  res.json({
    status,
    timestamp: new Date().toISOString(),
    uptime: Math.floor((Date.now() - serverStartTime) / 1000),
    sessions: {
      total: sessions.length,
      connected,
      connecting,
      disconnected
    }
  })
})

/**
 * Deep health check - requires auth
 * Used for less frequent polling (every 5min)
 */
router.get("/deep", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const manager = ConnectionManager.getInstance()
    const pool = new Pool({ connectionString: env.databaseUrl })

    // Test database connection
    const dbStart = Date.now()
    let dbConnected = false
    let dbLatency = 0
    try {
      await pool.query("SELECT 1")
      dbConnected = true
      dbLatency = Date.now() - dbStart
    } catch (err) {
      logger.error({ err }, "Database health check failed")
    }

    // Get detailed session info
    const sessions = manager.getAllSessionsStatus()

    // Get last message timestamps from database
    const sessionIds = sessions.map(s => s.sessionId)
    let lastMessageMap = new Map<string, Date | null>()

    if (sessionIds.length > 0) {
      try {
        const result = await pool.query(`
          SELECT session_id, MAX(timestamp) as last_message_at
          FROM whatsapp_explorer_messages
          WHERE session_id = ANY($1)
          GROUP BY session_id
        `, [sessionIds])

        for (const row of result.rows) {
          lastMessageMap.set(row.session_id, row.last_message_at)
        }
      } catch (err) {
        logger.warn({ err }, "Failed to get last message timestamps")
      }
    }

    await pool.end()

    // Determine overall status
    let status: "ok" | "degraded" | "error" = "ok"
    if (!dbConnected) {
      status = "error"
    } else {
      const disconnected = sessions.filter(s =>
        s.connectionStatus === "disconnected" || s.connectionStatus === "logged_out"
      ).length
      const connected = sessions.filter(s => s.connectionStatus === "connected").length

      if (disconnected > 0 && connected === 0) {
        status = "error"
      } else if (disconnected > 0) {
        status = "degraded"
      }
    }

    res.json({
      status,
      timestamp: new Date().toISOString(),
      uptime: Math.floor((Date.now() - serverStartTime) / 1000),
      database: {
        connected: dbConnected,
        latencyMs: dbLatency
      },
      sessions: sessions.map(s => ({
        sessionId: s.sessionId,
        phoneNumber: s.phoneNumber,
        connectionStatus: s.connectionStatus,
        lastConnectedAt: s.lastConnectedAt,
        lastMessageAt: lastMessageMap.get(s.sessionId) || null,
        socketAlive: s.socketAlive
      }))
    })
  } catch (error) {
    next(error)
  }
})

export default router
```

**Step 2: Update routes index to export health router**

Modify `whatsapp-server/src/routes/index.ts`, add import and route:

```typescript
import healthRouter from "./health.js"

// Add before other routes (health doesn't need full auth for light endpoint)
router.use("/health", healthRouter)
```

**Step 3: Remove old inline health endpoint from index.ts**

In `whatsapp-server/src/index.ts`, remove lines 54-61 (the inline `/health` endpoint):

```typescript
// REMOVE THIS:
// Health check (no auth required)
app.get("/health", (_req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    service: "whatsapp-baileys-server"
  })
})
```

**Step 4: Commit**

```bash
git add whatsapp-server/src/routes/health.ts whatsapp-server/src/routes/index.ts whatsapp-server/src/index.ts
git commit -m "feat(whatsapp-server): add health check endpoints (light + deep)"
```

---

## Task 3: Add getAllSessionsStatus Method to ConnectionManager

**Files:**
- Modify: `whatsapp-server/src/baileys/connection-manager.ts`

**Step 1: Add getAllSessionsStatus method**

Add this method to `ConnectionManager` class in `whatsapp-server/src/baileys/connection-manager.ts` after `getSessionStatus` method (around line 79):

```typescript
  /**
   * Get status of all active sessions (for health check)
   */
  getAllSessionsStatus(): Array<{
    sessionId: string
    connectionStatus: ConnectionStatus
    phoneNumber: string | null
    lastConnectedAt: Date | null
    socketAlive: boolean
  }> {
    const results: Array<{
      sessionId: string
      connectionStatus: ConnectionStatus
      phoneNumber: string | null
      lastConnectedAt: Date | null
      socketAlive: boolean
    }> = []

    for (const [sessionId, session] of this.sessions) {
      results.push({
        sessionId,
        connectionStatus: session.connectionStatus,
        phoneNumber: session.phoneNumber,
        lastConnectedAt: null, // Will be populated from DB in health route
        socketAlive: session.socket !== null && session.connectionStatus === "connected"
      })
    }

    return results
  }
```

**Step 2: Verify TypeScript compiles**

Run: `cd whatsapp-server && npx tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add whatsapp-server/src/baileys/connection-manager.ts
git commit -m "feat(whatsapp-server): add getAllSessionsStatus method for health checks"
```

---

## Task 4: Implement Auto-Connect on Server Startup

**Files:**
- Modify: `whatsapp-server/src/index.ts`
- Modify: `whatsapp-server/src/baileys/connection-manager.ts`

**Step 1: Add autoConnectPrimarySessions method to ConnectionManager**

Add to `ConnectionManager` class after `close` method:

```typescript
  /**
   * Auto-connect all primary sessions that have auth state
   * Called on server startup
   */
  async autoConnectPrimarySessions(): Promise<{
    attempted: number
    connected: number
    failed: string[]
  }> {
    logger.info("Starting auto-connect for primary sessions")

    const result = await this.pool.query(`
      SELECT id, session_name, phone_number
      FROM whatsapp_sessions
      WHERE session_name = 'primary'
        AND auth_state IS NOT NULL
        AND is_active = true
        AND auto_connect = true
    `)

    const sessions = result.rows
    logger.info({ count: sessions.length }, "Found primary sessions to auto-connect")

    const failed: string[] = []
    let connected = 0

    for (let i = 0; i < sessions.length; i++) {
      const session = sessions[i]
      logger.info(
        { sessionId: session.id, phoneNumber: session.phone_number, index: i + 1, total: sessions.length },
        "Auto-connecting session"
      )

      try {
        await this.connect(session.id)
        connected++
        logger.info({ sessionId: session.id }, "Auto-connect successful")
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error)
        logger.error({ sessionId: session.id, error: errorMsg }, "Auto-connect failed")
        failed.push(session.id)
      }

      // Stagger connections to avoid overwhelming WhatsApp
      if (i < sessions.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 2000))
      }
    }

    logger.info(
      { attempted: sessions.length, connected, failed: failed.length },
      "Auto-connect complete"
    )

    return { attempted: sessions.length, connected, failed }
  }
```

**Step 2: Call autoConnectPrimarySessions on server startup**

In `whatsapp-server/src/index.ts`, modify the server startup section (around line 85) to call auto-connect after server starts:

```typescript
// Start server
app.listen(env.port, async () => {
  logger.info({ port: env.port }, "WhatsApp Baileys Server started")
  logger.info({ nextjsAppUrl: env.nextjsAppUrl }, "CORS configured for")

  // Auto-connect primary sessions after server starts
  try {
    const manager = ConnectionManager.getInstance()
    const result = await manager.autoConnectPrimarySessions()
    logger.info(
      { attempted: result.attempted, connected: result.connected, failed: result.failed.length },
      "Auto-connect complete"
    )
  } catch (error) {
    logger.error({ error }, "Auto-connect failed")
  }
})
```

**Step 3: Verify TypeScript compiles**

Run: `cd whatsapp-server && npx tsc --noEmit`
Expected: No errors

**Step 4: Commit**

```bash
git add whatsapp-server/src/index.ts whatsapp-server/src/baileys/connection-manager.ts
git commit -m "feat(whatsapp-server): auto-connect primary sessions on startup"
```

---

## Task 5: Add Reconnect Endpoint

**Files:**
- Modify: `whatsapp-server/src/routes/sessions.ts`
- Modify: `whatsapp-server/src/baileys/connection-manager.ts`

**Step 1: Add reconnect method to ConnectionManager**

Add to `ConnectionManager` class after `disconnect` method:

```typescript
  /**
   * Reconnect a session (disconnect then connect)
   */
  async reconnect(sessionId: string): Promise<void> {
    logger.info({ sessionId }, "Reconnecting session")

    // Disconnect if currently connected
    const session = this.sessions.get(sessionId)
    if (session?.socket) {
      session.socket.end(undefined)
      this.sessions.delete(sessionId)
    }

    // Small delay before reconnecting
    await new Promise(resolve => setTimeout(resolve, 1000))

    // Reconnect
    await this.connect(sessionId)
  }
```

**Step 2: Add reconnect endpoint to sessions router**

Add to `whatsapp-server/src/routes/sessions.ts` after the logout endpoint:

```typescript
// Reconnect session (disconnect and reconnect)
router.post("/:sessionId/reconnect", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { sessionId } = req.params
    const manager = ConnectionManager.getInstance()

    logger.info({ sessionId }, "Reconnect request received")
    await manager.reconnect(sessionId)

    res.json({
      success: true,
      message: "Reconnection initiated",
      sessionId
    })
  } catch (error) {
    next(error)
  }
})
```

**Step 3: Verify TypeScript compiles**

Run: `cd whatsapp-server && npx tsc --noEmit`
Expected: No errors

**Step 4: Commit**

```bash
git add whatsapp-server/src/routes/sessions.ts whatsapp-server/src/baileys/connection-manager.ts
git commit -m "feat(whatsapp-server): add reconnect endpoint"
```

---

## Task 6: Update Graceful Shutdown to Update Database Status

**Files:**
- Modify: `whatsapp-server/src/index.ts`

**Step 1: Enhance shutdown handler**

Replace the `shutdown` function in `whatsapp-server/src/index.ts`:

```typescript
// Graceful shutdown
async function shutdown() {
  logger.info("Shutting down...")

  const manager = ConnectionManager.getInstance()

  // Update all sessions to disconnected in database before closing
  try {
    await manager.updateAllSessionsToDisconnected()
  } catch (error) {
    logger.error({ error }, "Failed to update session statuses during shutdown")
  }

  await manager.close()
  process.exit(0)
}
```

**Step 2: Add updateAllSessionsToDisconnected method to ConnectionManager**

Add to `ConnectionManager` class:

```typescript
  /**
   * Update all active sessions to disconnected status in database
   * Called during graceful shutdown
   */
  async updateAllSessionsToDisconnected(): Promise<void> {
    const sessionIds = Array.from(this.sessions.keys())

    if (sessionIds.length === 0) {
      return
    }

    logger.info({ count: sessionIds.length }, "Updating sessions to disconnected for shutdown")

    await this.pool.query(`
      UPDATE whatsapp_sessions
      SET connection_status = 'disconnected',
          last_disconnected_at = NOW(),
          updated_at = NOW()
      WHERE id = ANY($1)
    `, [sessionIds])
  }
```

**Step 3: Verify TypeScript compiles**

Run: `cd whatsapp-server && npx tsc --noEmit`
Expected: No errors

**Step 4: Commit**

```bash
git add whatsapp-server/src/index.ts whatsapp-server/src/baileys/connection-manager.ts
git commit -m "feat(whatsapp-server): update session status on graceful shutdown"
```

---

## Task 7: Create Health Actions for Next.js App

**Files:**
- Create: `actions/whatsapp-health-actions.ts`

**Step 1: Create health actions file**

Create `actions/whatsapp-health-actions.ts`:

```typescript
"use server"

import { ActionState } from "@/types"

export interface HealthStatus {
  status: "ok" | "degraded" | "error"
  timestamp: string
  uptime: number
  sessions: {
    total: number
    connected: number
    connecting: number
    disconnected: number
  }
}

export interface DeepHealthStatus {
  status: "ok" | "degraded" | "error"
  timestamp: string
  uptime: number
  database: {
    connected: boolean
    latencyMs: number
  }
  sessions: Array<{
    sessionId: string
    phoneNumber: string | null
    connectionStatus: string
    lastConnectedAt: string | null
    lastMessageAt: string | null
    socketAlive: boolean
  }>
}

/**
 * Get lightweight health status (no auth, for frequent polling)
 */
export async function getWhatsAppHealthAction(): Promise<ActionState<HealthStatus>> {
  try {
    const serverUrl = process.env.WHATSAPP_SERVER_URL || "http://localhost:3001"

    const response = await fetch(`${serverUrl}/health`, {
      cache: "no-store"
    })

    if (!response.ok) {
      return {
        isSuccess: false,
        message: `Health check failed: ${response.status}`
      }
    }

    const data = await response.json() as HealthStatus

    return {
      isSuccess: true,
      message: "Health check successful",
      data
    }
  } catch (error) {
    // Server unreachable
    return {
      isSuccess: true,
      message: "Server unreachable",
      data: {
        status: "error",
        timestamp: new Date().toISOString(),
        uptime: 0,
        sessions: {
          total: 0,
          connected: 0,
          connecting: 0,
          disconnected: 0
        }
      }
    }
  }
}

/**
 * Get deep health status (requires auth, for less frequent polling)
 */
export async function getWhatsAppDeepHealthAction(): Promise<ActionState<DeepHealthStatus>> {
  try {
    const serverUrl = process.env.WHATSAPP_SERVER_URL || "http://localhost:3001"
    const apiKey = process.env.WHATSAPP_SERVER_API_KEY || ""

    const response = await fetch(`${serverUrl}/health/deep`, {
      headers: {
        "x-api-key": apiKey
      },
      cache: "no-store"
    })

    if (!response.ok) {
      return {
        isSuccess: false,
        message: `Deep health check failed: ${response.status}`
      }
    }

    const data = await response.json() as DeepHealthStatus

    return {
      isSuccess: true,
      message: "Deep health check successful",
      data
    }
  } catch (error) {
    return {
      isSuccess: false,
      message: error instanceof Error ? error.message : "Deep health check failed"
    }
  }
}

/**
 * Trigger reconnect for a session
 */
export async function reconnectWhatsAppSessionAction(
  sessionId: string
): Promise<ActionState<void>> {
  try {
    const serverUrl = process.env.WHATSAPP_SERVER_URL || "http://localhost:3001"
    const apiKey = process.env.WHATSAPP_SERVER_API_KEY || ""

    const response = await fetch(`${serverUrl}/sessions/${sessionId}/reconnect`, {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "Content-Type": "application/json"
      }
    })

    if (!response.ok) {
      const data = await response.json()
      return {
        isSuccess: false,
        message: data.error || `Reconnect failed: ${response.status}`
      }
    }

    return {
      isSuccess: true,
      message: "Reconnection initiated",
      data: undefined
    }
  } catch (error) {
    return {
      isSuccess: false,
      message: error instanceof Error ? error.message : "Reconnect failed"
    }
  }
}
```

**Step 2: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 3: Commit**

```bash
git add actions/whatsapp-health-actions.ts
git commit -m "feat(actions): add WhatsApp health check actions"
```

---

## Task 8: Create WhatsApp Status Context

**Files:**
- Create: `app/(authenticated)/dashboard/_context/whatsapp-status-context.tsx`

**Step 1: Create the context file**

Create `app/(authenticated)/dashboard/_context/whatsapp-status-context.tsx`:

```typescript
"use client"

import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from "react"
import {
  getWhatsAppHealthAction,
  getWhatsAppDeepHealthAction,
  reconnectWhatsAppSessionAction,
  type HealthStatus,
  type DeepHealthStatus
} from "@/actions/whatsapp-health-actions"
import { getPrimaryWhatsAppSessionAction } from "@/actions/whatsapp-primary-session-actions"

interface WhatsAppStatusState {
  // Binary status for UI (green/red)
  status: "connected" | "disconnected"
  // Server reachability
  serverReachable: boolean
  // Detailed connection status
  connectionStatus: string
  // Phone number if connected
  phoneNumber: string | null
  // Session ID for reconnect
  sessionId: string | null
  // Last check timestamp
  lastChecked: Date | null
  // Last error message
  lastError: string | null
  // Currently checking
  isChecking: boolean
  // Server uptime (seconds)
  uptime: number
  // Reconnect function
  reconnect: () => Promise<void>
  // Force refresh
  refresh: () => Promise<void>
}

const WhatsAppStatusContext = createContext<WhatsAppStatusState | null>(null)

const LIGHT_POLL_INTERVAL = 30 * 1000  // 30 seconds
const DEEP_POLL_INTERVAL = 5 * 60 * 1000  // 5 minutes
const FAST_POLL_INTERVAL = 5 * 1000  // 5 seconds (when server just restarted)

export function WhatsAppStatusProvider({
  children,
  userProfileId
}: {
  children: React.ReactNode
  userProfileId: string
}) {
  const [state, setState] = useState<Omit<WhatsAppStatusState, "reconnect" | "refresh">>({
    status: "disconnected",
    serverReachable: false,
    connectionStatus: "unknown",
    phoneNumber: null,
    sessionId: null,
    lastChecked: null,
    lastError: null,
    isChecking: true,
    uptime: 0
  })

  const lightPollRef = useRef<NodeJS.Timeout | null>(null)
  const deepPollRef = useRef<NodeJS.Timeout | null>(null)
  const isVisibleRef = useRef(true)

  const checkHealth = useCallback(async (deep: boolean = false) => {
    setState(prev => ({ ...prev, isChecking: true }))

    try {
      // Get session ID first
      const sessionResult = await getPrimaryWhatsAppSessionAction(userProfileId)
      const sessionId = sessionResult.isSuccess ? sessionResult.data?.sessionId || null : null

      // Get health status
      const healthResult = deep
        ? await getWhatsAppDeepHealthAction()
        : await getWhatsAppHealthAction()

      if (!healthResult.isSuccess || !healthResult.data) {
        setState(prev => ({
          ...prev,
          status: "disconnected",
          serverReachable: false,
          connectionStatus: "server_error",
          lastError: healthResult.message,
          lastChecked: new Date(),
          isChecking: false,
          sessionId
        }))
        return
      }

      const data = healthResult.data
      const serverReachable = true
      const hasConnectedSession = data.sessions.connected > 0

      // Determine binary status
      const status: "connected" | "disconnected" =
        serverReachable && hasConnectedSession ? "connected" : "disconnected"

      // Determine detailed status
      let connectionStatus = "disconnected"
      if (data.sessions.connected > 0) {
        connectionStatus = "connected"
      } else if (data.sessions.connecting > 0) {
        connectionStatus = "connecting"
      }

      // Get phone number from deep health if available
      let phoneNumber: string | null = null
      if (deep && "sessions" in data && Array.isArray((data as DeepHealthStatus).sessions)) {
        const sessions = (data as DeepHealthStatus).sessions
        const connectedSession = sessions.find(s => s.connectionStatus === "connected")
        phoneNumber = connectedSession?.phoneNumber || null
      }

      setState(prev => ({
        ...prev,
        status,
        serverReachable,
        connectionStatus,
        phoneNumber: phoneNumber || prev.phoneNumber,
        sessionId,
        lastChecked: new Date(),
        lastError: null,
        isChecking: false,
        uptime: data.uptime
      }))
    } catch (error) {
      setState(prev => ({
        ...prev,
        status: "disconnected",
        serverReachable: false,
        connectionStatus: "error",
        lastError: error instanceof Error ? error.message : "Unknown error",
        lastChecked: new Date(),
        isChecking: false
      }))
    }
  }, [userProfileId])

  const reconnect = useCallback(async () => {
    if (!state.sessionId) return

    setState(prev => ({ ...prev, isChecking: true, connectionStatus: "reconnecting" }))

    const result = await reconnectWhatsAppSessionAction(state.sessionId)

    if (!result.isSuccess) {
      setState(prev => ({
        ...prev,
        lastError: result.message,
        isChecking: false
      }))
      return
    }

    // Poll more frequently after reconnect attempt
    await checkHealth(false)
  }, [state.sessionId, checkHealth])

  const refresh = useCallback(async () => {
    await checkHealth(true)
  }, [checkHealth])

  // Initial check and polling setup
  useEffect(() => {
    // Initial check (deep)
    checkHealth(true)

    // Set up polling intervals
    const startPolling = () => {
      // Light poll every 30s
      lightPollRef.current = setInterval(() => {
        if (isVisibleRef.current) {
          checkHealth(false)
        }
      }, LIGHT_POLL_INTERVAL)

      // Deep poll every 5min
      deepPollRef.current = setInterval(() => {
        if (isVisibleRef.current) {
          checkHealth(true)
        }
      }, DEEP_POLL_INTERVAL)
    }

    startPolling()

    // Visibility change handler
    const handleVisibilityChange = () => {
      isVisibleRef.current = document.visibilityState === "visible"

      if (isVisibleRef.current) {
        // Immediate check when tab becomes visible
        checkHealth(false)
      }
    }

    document.addEventListener("visibilitychange", handleVisibilityChange)

    return () => {
      if (lightPollRef.current) clearInterval(lightPollRef.current)
      if (deepPollRef.current) clearInterval(deepPollRef.current)
      document.removeEventListener("visibilitychange", handleVisibilityChange)
    }
  }, [checkHealth])

  return (
    <WhatsAppStatusContext.Provider value={{ ...state, reconnect, refresh }}>
      {children}
    </WhatsAppStatusContext.Provider>
  )
}

export function useWhatsAppStatus() {
  const context = useContext(WhatsAppStatusContext)
  if (!context) {
    throw new Error("useWhatsAppStatus must be used within WhatsAppStatusProvider")
  }
  return context
}
```

**Step 2: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 3: Commit**

```bash
git add app/(authenticated)/dashboard/_context/whatsapp-status-context.tsx
git commit -m "feat(context): add WhatsApp status context with polling"
```

---

## Task 9: Create WhatsApp Status Dot Component (Header)

**Files:**
- Create: `app/(authenticated)/dashboard/_components/whatsapp-status-dot.tsx`

**Step 1: Create the component**

Create `app/(authenticated)/dashboard/_components/whatsapp-status-dot.tsx`:

```typescript
"use client"

import { useWhatsAppStatus } from "../_context/whatsapp-status-context"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger
} from "@/components/ui/tooltip"
import {
  Popover,
  PopoverContent,
  PopoverTrigger
} from "@/components/ui/popover"
import { Button } from "@/components/ui/button"
import { RefreshCw, Settings } from "lucide-react"
import Link from "next/link"
import { cn } from "@/lib/utils"

export function WhatsAppStatusDot() {
  const {
    status,
    connectionStatus,
    lastError,
    phoneNumber,
    isChecking,
    reconnect,
    refresh
  } = useWhatsAppStatus()

  const isConnected = status === "connected"

  const formatPhoneNumber = (phone: string) => {
    // Mask middle digits: +27 **** 1234
    if (phone.length < 8) return phone
    return `+${phone.slice(0, 2)} ${"*".repeat(4)} ${phone.slice(-4)}`
  }

  return (
    <Popover>
      <TooltipProvider>
        <Tooltip>
          <PopoverTrigger asChild>
            <TooltipTrigger asChild>
              <button
                className={cn(
                  "h-2.5 w-2.5 rounded-full transition-all duration-300",
                  isConnected
                    ? "bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]"
                    : "bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]",
                  isChecking && "animate-pulse"
                )}
                aria-label={`WhatsApp ${isConnected ? "connected" : "disconnected"}`}
              />
            </TooltipTrigger>
          </PopoverTrigger>
          <TooltipContent side="bottom">
            <p>WhatsApp: {isConnected ? "Connected" : "Disconnected"}</p>
            {!isConnected && <p className="text-xs text-muted-foreground">Click for details</p>}
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      <PopoverContent className="w-72" align="end">
        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <div className={cn(
              "h-3 w-3 rounded-full",
              isConnected ? "bg-green-500" : "bg-red-500"
            )} />
            <span className="font-medium">
              WhatsApp {isConnected ? "Connected" : "Offline"}
            </span>
          </div>

          {phoneNumber && (
            <p className="text-sm text-muted-foreground">
              {formatPhoneNumber(phoneNumber)}
            </p>
          )}

          <p className="text-xs text-muted-foreground">
            Status: {connectionStatus}
          </p>

          {lastError && (
            <p className="text-xs text-red-500">
              {lastError}
            </p>
          )}

          <div className="flex gap-2 pt-2 border-t">
            {!isConnected && (
              <Button
                size="sm"
                variant="outline"
                onClick={reconnect}
                disabled={isChecking}
                className="flex-1"
              >
                <RefreshCw className={cn("h-3 w-3 mr-1", isChecking && "animate-spin")} />
                Reconnect
              </Button>
            )}
            <Button size="sm" variant="outline" onClick={refresh} disabled={isChecking}>
              <RefreshCw className={cn("h-3 w-3", isChecking && "animate-spin")} />
            </Button>
            <Button size="sm" variant="ghost" asChild>
              <Link href="/dashboard/settings/whatsapp">
                <Settings className="h-3 w-3" />
              </Link>
            </Button>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  )
}
```

**Step 2: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 3: Commit**

```bash
git add app/(authenticated)/dashboard/_components/whatsapp-status-dot.tsx
git commit -m "feat(ui): add WhatsApp status dot component for header"
```

---

## Task 10: Create WhatsApp Status Badge Component (Sidebar)

**Files:**
- Create: `app/(authenticated)/dashboard/_components/whatsapp-status-badge.tsx`

**Step 1: Create the component**

Create `app/(authenticated)/dashboard/_components/whatsapp-status-badge.tsx`:

```typescript
"use client"

import { useWhatsAppStatus } from "../_context/whatsapp-status-context"
import { Button } from "@/components/ui/button"
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger
} from "@/components/ui/collapsible"
import { RefreshCw, Settings, ChevronDown, MessageCircle } from "lucide-react"
import Link from "next/link"
import { cn } from "@/lib/utils"
import { useState } from "react"

export function WhatsAppStatusBadge() {
  const {
    status,
    connectionStatus,
    lastError,
    phoneNumber,
    lastChecked,
    isChecking,
    uptime,
    reconnect,
    refresh
  } = useWhatsAppStatus()

  const [isOpen, setIsOpen] = useState(false)

  const isConnected = status === "connected"

  const formatPhoneNumber = (phone: string) => {
    if (phone.length < 8) return phone
    return `+${phone.slice(0, 2)} ${"*".repeat(4)} ${phone.slice(-4)}`
  }

  const formatLastChecked = (date: Date | null) => {
    if (!date) return "Never"
    const seconds = Math.floor((Date.now() - date.getTime()) / 1000)
    if (seconds < 60) return "Just now"
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`
    return `${Math.floor(seconds / 3600)}h ago`
  }

  const formatUptime = (seconds: number) => {
    if (seconds < 60) return `${seconds}s`
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m`
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`
    return `${Math.floor(seconds / 86400)}d`
  }

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen} className="w-full">
      <CollapsibleTrigger asChild>
        <button className="flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-sm hover:bg-accent transition-colors">
          <MessageCircle className="h-4 w-4 text-muted-foreground" />
          <div className={cn(
            "h-2 w-2 rounded-full",
            isConnected ? "bg-green-500" : "bg-red-500"
          )} />
          <span className="flex-1 text-left text-muted-foreground">
            WhatsApp {isConnected ? "Online" : "Offline"}
          </span>
          <ChevronDown className={cn(
            "h-4 w-4 text-muted-foreground transition-transform",
            isOpen && "rotate-180"
          )} />
        </button>
      </CollapsibleTrigger>

      <CollapsibleContent className="px-2 pb-2">
        <div className="space-y-2 rounded-md bg-muted/50 p-2 text-xs">
          {phoneNumber && (
            <div className="flex justify-between">
              <span className="text-muted-foreground">Phone</span>
              <span>{formatPhoneNumber(phoneNumber)}</span>
            </div>
          )}

          <div className="flex justify-between">
            <span className="text-muted-foreground">Status</span>
            <span className="capitalize">{connectionStatus.replace("_", " ")}</span>
          </div>

          <div className="flex justify-between">
            <span className="text-muted-foreground">Last check</span>
            <span>{formatLastChecked(lastChecked)}</span>
          </div>

          {uptime > 0 && (
            <div className="flex justify-between">
              <span className="text-muted-foreground">Server uptime</span>
              <span>{formatUptime(uptime)}</span>
            </div>
          )}

          {lastError && (
            <p className="text-red-500 pt-1 border-t">
              {lastError}
            </p>
          )}

          <div className="flex gap-1 pt-2 border-t">
            {!isConnected && (
              <Button
                size="sm"
                variant="outline"
                onClick={reconnect}
                disabled={isChecking}
                className="flex-1 h-7 text-xs"
              >
                <RefreshCw className={cn("h-3 w-3 mr-1", isChecking && "animate-spin")} />
                Reconnect
              </Button>
            )}
            <Button
              size="sm"
              variant="outline"
              onClick={refresh}
              disabled={isChecking}
              className="h-7 px-2"
            >
              <RefreshCw className={cn("h-3 w-3", isChecking && "animate-spin")} />
            </Button>
            <Button size="sm" variant="ghost" asChild className="h-7 px-2">
              <Link href="/dashboard/settings/whatsapp">
                <Settings className="h-3 w-3" />
              </Link>
            </Button>
          </div>
        </div>
      </CollapsibleContent>
    </Collapsible>
  )
}
```

**Step 2: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 3: Commit**

```bash
git add app/(authenticated)/dashboard/_components/whatsapp-status-badge.tsx
git commit -m "feat(ui): add WhatsApp status badge component for sidebar"
```

---

## Task 11: Integrate Status Components into Layout

**Files:**
- Modify: `app/(authenticated)/dashboard/_components/layout-client.tsx`
- Modify: `app/(authenticated)/dashboard/_components/app-sidebar.tsx`
- Modify: `app/(authenticated)/dashboard/layout.tsx`

**Step 1: Update layout.tsx to pass userProfileId**

First, read `app/(authenticated)/dashboard/layout.tsx` to understand current structure, then modify to pass `userProfileId` to client layout.

Add to the server component data fetching:
```typescript
// In the layout.tsx server component, ensure userProfileId is passed to the client
```

**Step 2: Update layout-client.tsx to include provider and header dot**

Modify `app/(authenticated)/dashboard/_components/layout-client.tsx`:

Add imports at top:
```typescript
import { WhatsAppStatusProvider } from "../_context/whatsapp-status-context"
import { WhatsAppStatusDot } from "./whatsapp-status-dot"
```

Add `userProfileId` to props interface:
```typescript
export default function DashboardClientLayout({
  children,
  userData,
  userType,
  userProfileId  // Add this
}: {
  children: React.ReactNode
  userData: {
    name: string
    email: string
    avatar: string
    membership: string
  }
  userType: "landlord" | "rental_agent" | "tenant" | "admin"
  userProfileId: string  // Add this
}) {
```

Wrap entire return with provider and add dot to header:
```typescript
return (
  <WhatsAppStatusProvider userProfileId={userProfileId}>
    <SidebarProvider defaultOpen={defaultOpen}>
      {/* ... existing code ... */}
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 transition-[width,height] ease-linear group-has-data-[collapsible=icon]/sidebar-wrapper:h-12">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator
              orientation="vertical"
              className="mr-2 data-[orientation=vertical]:h-4"
            />
            {/* Breadcrumbs */}
          </div>
          {/* Add status dot to right side of header */}
          <div className="ml-auto pr-4">
            <WhatsAppStatusDot />
          </div>
        </header>
        {/* ... rest of content ... */}
      </SidebarInset>
    </SidebarProvider>
  </WhatsAppStatusProvider>
)
```

**Step 3: Update app-sidebar.tsx to include status badge**

Modify `app/(authenticated)/dashboard/_components/app-sidebar.tsx`:

Add import:
```typescript
import { WhatsAppStatusBadge } from "./whatsapp-status-badge"
```

Add badge to SidebarFooter (before NavUser):
```typescript
<SidebarFooter>
  <WhatsAppStatusBadge />
  <NavUser user={data.user} userType={userType} />
</SidebarFooter>
```

**Step 4: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 5: Commit**

```bash
git add app/(authenticated)/dashboard/_components/layout-client.tsx app/(authenticated)/dashboard/_components/app-sidebar.tsx app/(authenticated)/dashboard/layout.tsx
git commit -m "feat(ui): integrate WhatsApp status into dashboard layout"
```

---

## Task 12: Add reconnect Method to Baileys Client Library

**Files:**
- Modify: `lib/whatsapp-baileys-client.ts`

**Step 1: Add reconnect method**

Add to `WhatsAppBaileysClient` class in `lib/whatsapp-baileys-client.ts`:

```typescript
  /**
   * Reconnect a session
   */
  async reconnect(sessionId: string): Promise<{ success: boolean; message: string }> {
    return this.request(`/sessions/${sessionId}/reconnect`, {
      method: "POST"
    })
  }
```

**Step 2: Verify TypeScript compiles**

Run: `npm run types`
Expected: No errors

**Step 3: Commit**

```bash
git add lib/whatsapp-baileys-client.ts
git commit -m "feat(lib): add reconnect method to baileys client"
```

---

## Task 13: Final Testing and Verification

**Step 1: Build WhatsApp server**

Run: `cd whatsapp-server && npm run build`
Expected: Build succeeds without errors

**Step 2: Run Next.js type check**

Run: `npm run types`
Expected: No type errors

**Step 3: Run linting**

Run: `npm run lint`
Expected: No lint errors (or only pre-existing ones)

**Step 4: Test build**

Run: `npm run build`
Expected: Build completes successfully

**Step 5: Commit any final fixes**

If there are any fixes needed:
```bash
git add -A
git commit -m "fix: address build/lint issues"
```

---

## Summary

**Total Tasks:** 13

**Files Created:**
- `actions/whatsapp-health-actions.ts`
- `app/(authenticated)/dashboard/_context/whatsapp-status-context.tsx`
- `app/(authenticated)/dashboard/_components/whatsapp-status-dot.tsx`
- `app/(authenticated)/dashboard/_components/whatsapp-status-badge.tsx`
- `whatsapp-server/src/routes/health.ts`

**Files Modified:**
- `db/schema/whatsapp-sessions.ts`
- `whatsapp-server/src/index.ts`
- `whatsapp-server/src/routes/index.ts`
- `whatsapp-server/src/routes/sessions.ts`
- `whatsapp-server/src/baileys/connection-manager.ts`
- `app/(authenticated)/dashboard/_components/layout-client.tsx`
- `app/(authenticated)/dashboard/_components/app-sidebar.tsx`
- `app/(authenticated)/dashboard/layout.tsx`
- `lib/whatsapp-baileys-client.ts`

**Key Features Implemented:**
1. Database column for auto-connect preference
2. Health check endpoints (light + deep)
3. Auto-connect on server startup
4. Reconnect endpoint
5. Graceful shutdown with DB status update
6. Front-end health polling context
7. Header status dot with popover
8. Sidebar status badge with collapsible details
